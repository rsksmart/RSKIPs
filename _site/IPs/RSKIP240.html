<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Implement Storage Rent in RSK | RSK Improvement Proposals</title>
    <meta
      property="og:title"
      content="Implement Storage Rent in RSK | RSK Improvement Proposals"
    />
    <meta name="description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />

  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="https://ips.rsk.co/IPs/RSKIP240" />
  <meta property="og:url" content="https://ips.rsk.co/IPs/RSKIP240" />
  <meta property="og:site_name" content="RSK Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "https://ips.rsk.co",
      "name": "RSK Improvement Proposals",
      "description": "RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" />
      <!-- Google Fonts -->
      <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700,900&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,600,700,800&display=swap" rel="stylesheet"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="RSK Improvement Proposals" /><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-nlrDrBTHxJJlDDX22AS33xYI1OJHnGMDhiYMSe2U0e0=" crossorigin="anonymous"></script>
</head>
<body><header class="site-header" role="banner">
  <button id="dark-mode-toggle" class="dark-mode-toggle theme-toggle-button">
    <svg class="icon" style="width:24px;height:24px" viewBox="0 0 24 24">
      <path fill="currentColor" d="M7.5,2C5.71,3.15 4.5,5.18 4.5,7.5C4.5,9.82 5.71,11.85 7.53,13C4.46,13 2,10.54 2,7.5A5.5,5.5 0 0,1 7.5,2M19.07,3.5L20.5,4.93L4.93,20.5L3.5,19.07L19.07,3.5M12.89,5.93L11.41,5L9.97,6L10.39,4.3L9,3.24L10.75,3.12L11.33,1.47L12,3.1L13.73,3.13L12.38,4.26L12.89,5.93M9.59,9.54L8.43,8.81L7.31,9.59L7.65,8.27L6.56,7.44L7.92,7.35L8.37,6.06L8.88,7.33L10.24,7.36L9.19,8.23L9.59,9.54M19,13.5A5.5,5.5 0 0,1 13.5,19C12.28,19 11.15,18.6 10.24,17.93L17.93,10.24C18.6,11.15 19,12.28 19,13.5M14.6,20.08L17.37,18.93L17.13,22.28L14.6,20.08M18.93,17.38L20.08,14.61L22.28,17.15L18.93,17.38M20.08,12.42L18.94,9.64L22.28,9.88L20.08,12.42M9.63,18.93L12.4,20.08L9.87,22.27L9.63,18.93Z" />
    </svg>
  </button>


<div class="wrapper"><a class="site-title" rel="author" href="/">RSK Improvement Proposals</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link underline" href="/all">All</a><a class="page-link underline" href="/scalability">Scalability</a><a class="page-link underline" href="/security">Security</a><a class="page-link underline" href="/usability">Usability</a><a class="page-link underline" href="/fairness">Fairness</a><a class="page-link underline" href="/standardtrack">Standard Track</a></div>





      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Implement Storage Rent in RSK</h1>
  </header>

  <div class="post-content">
    <h1 id="implement-storage-rent-in-rsk">Implement Storage Rent in RSK</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">240</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Implement Storage Rent in RSK</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">27-APR-21</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">SDL, SM, DM</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Sca, Sec, Fair</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">2</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Draft</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Discussions-to</strong></td>
      <td style="text-align: left">https://research.rsk.dev/t/rskip-240-implement-storage-rent-in-rsk/163</td>
    </tr>
  </tbody>
</table>

<h2 id="abstract">Abstract</h2>
<p>Storage rent is a <em>variable fee</em> collected from transaction senders to offset the cost of <em>retrieving relevant information</em> from blockchain state to execute transactions. The fee is called “rent” because it depends on the <em>time duration</em> for which the relevant data are stored in the <em>unitrie</em>. Rent is computed for each value-containing unitrie node “touched by” a transaction. This includes nodes containing account information, contract code and storage cells. Transaction senders currently pay <em>fixed costs</em> in gas for trie access through opcodes like <code class="language-plaintext highlighter-rouge">SLOAD</code>, <code class="language-plaintext highlighter-rouge">BAL</code>, <code class="language-plaintext highlighter-rouge">CALL</code> etc. Rent is an additional <em>variable cost</em> with a <em>cap</em> or limit. A trie node’s rent is computed using a <em>timestamp</em> of that node’s previous rent payment. The general idea is that these variable costs will be negligible for nodes that are accessed frequently and thus are more likely to be cached. However, the longer a node remains <em>unused</em>, the more outstanding rent it accumulates, and the more it will cost (with some cap) to read. Such nodes are less likely to be cached in memory.</p>

<h2 id="motivation">Motivation</h2>

<p>Storage rent introduces variable fees for trie access. These fees can help in the following ways</p>

<ul>
  <li>make storage payments fairer by introducing a <em>time dimension</em> to storage fees</li>
  <li>improve state caching by <em>introducing a cache hierarchy</em></li>
  <li>help secure the network from some IO attacks by making disk IO more expensive</li>
  <li>reduce the risk of storage spam and gas arbitrage</li>
  <li>encourage developers and product designers to treat state storage more judiciously - important for long term scalability, sustainability and fairness</li>
</ul>

<h3 id="why-introduce-rent-now">Why introduce rent now</h3>

<p>RSK is a relatively young blockchain and the above factors are not really pressing issues at the moment. However, the RSK community is working towards massive growth and user adoption. If successful, then introducing new economic mechanisms (such as storage rent) later can become more challenging and potentially disruptive. For illustration, one can look at Ethereum’s experience. Despite continuing support from several core developers and researchers, the Ethereum community has struggled to reach consensus on introducing rent. Their experience illustrates that introducing a new pricing system in a mature and popular blockchain can be extremely challenging.</p>

<p>Whenever practical, the RSK community tries to maintain compatibility with Ethereum. In the future, should the Ethereum community (or another public chain) come up with a clearly superior system for state size management, then we can always implement the same in RSK.</p>

<h2 id="specification">Specification</h2>

<p>Storage rent is not a new idea - it is mentioned in the RSK whitepaper [1]. It has also been proposed in Ethereum multiple times with varying designs [2, 3]. The current proposal has been influenced by several prior RSKIPs including <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP21.md">RSKIP21</a>, <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP52.md">RSKIP52</a>, <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP61.md">RSKIP61</a> and <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP113.md">RSKIP113</a>. See [4] for additional background information.</p>

<p>This proposal requires a hard fork.</p>

<h3 id="trie-changes">Trie changes</h3>

<ul>
  <li>Add a field <code class="language-plaintext highlighter-rouge">lastRentPaidTime</code> to the unitrie.</li>
</ul>

<p>This is a time stamp in unix seconds for each unitrie node. This is interpreted as the time until which rent has been “fully paid”. This timestamp will typically lie <em>in the past</em> because rent is not paid in advance. The timestamp is moved forward with each rent payment, with the rate of advance depending on both the payment amount and the size of data stored in the node.</p>

<ul>
  <li>Add another field <code class="language-plaintext highlighter-rouge">nodeVersion</code> to the unitrie. 
 for at the point a transaction execution stops
Node versioning is required for serialization of new trie nodes with rent timestamps and older nodes without timestamps. We can use version number 0 for Orchid encoding, 1 for the current encoding (RSKIP107), and 2 for nodes with rent time stamp (current proposal). Note that the current implementation of RSKJ already uses implicit node version 1 in bit positions 6 and 7 of <code class="language-plaintext highlighter-rouge">flags</code> in Trie class. This will be changed to 2 (<code class="language-plaintext highlighter-rouge">10</code> in binary) for storage rent.</li>
</ul>

<h3 id="rent-computation">Rent computation</h3>

<p><strong>Reference Time:</strong> The timestamp of the current block (where the transaction is included) should be used as the reference time for calculating time deltas for rent computations.</p>

<p>Rent is computed and tracked at the granularity of individual <em>value-containing</em> unitrie nodes. Rent accounting follows a <em>pay-after-use</em> model. The rent for a trie node depends on three factors:</p>

<ol>
  <li>the node’s size (in bytes)</li>
  <li>the duration (in seconds) since rent was last paid (fully).</li>
  <li>and the <strong>rental rate</strong> <code class="language-plaintext highlighter-rouge">R = 1/2^21 gas/byte/second</code> (approximately <strong>15 gas per byte per year</strong>)</li>
</ol>

<p>A node’s size (<code class="language-plaintext highlighter-rouge">nodeSize</code>) is computed as the node’s value length plus 128 bytes for storage overhead. Therefore, <code class="language-plaintext highlighter-rouge">nodeSize</code> only approximates the actual space consumed, e.g. it doesn’t take into account embedded nodes.</p>

<p>Illustrative <strong>approximate</strong> examples of rent</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">(10+128)*15 ~ 2100 gas/year</code> for an account with 10 bytes of data</li>
  <li><code class="language-plaintext highlighter-rouge">(32+128)*15 ~ 2500 gas/year</code> for a storage cell (32 bytes maximum)</li>
  <li><code class="language-plaintext highlighter-rouge">(2500+128)*15 ~ 40000 gas/year</code> for a contract of size 2500 bytes (about the size of an ERC20 token contract)</li>
</ul>

<h3 id="rent-collection-thresholds-and-caps">Rent Collection Thresholds and Caps</h3>

<p>The dependence on timestamps makes rent payments <em>variable</em>. These are <strong>capped</strong> on a <em>per-transaction</em> basis, so a trie node’s rent payments get spread across different transactions and across users (transaction senders).</p>

<p>Updating a node’s rent timestamp requires a trie <em>put</em> operation, which can affect performance. To reduce the number of trie writes “driven by” timestamp updates, we require some minimum “collection thresholds” on the amount of rent that is due. This threshold is different for trie reads and trie writes.</p>

<p>Rent <em>does not</em> depend directly on opcodes. It depends on the type of node accessed. The reference to opcodes here is mostly for illustration. Some operations such as <code class="language-plaintext highlighter-rouge">CALL</code> can touch several trie nodes (accounts, code, storage). It is also common for the same trie node to be touched <em>multiple times</em>, in <em>different ways</em>, and at <em>different call depths</em> within the same transaction. Within a single call frame, the amount of rent collected in a transaction should not depend on the order in which or the number of times a trie node is accessed. Naturally, the order of access does matter at different call depths.</p>

<p>When a <em>pre-existing</em> value is updated in the trie, then the additional performance cost of updating its rent timestamp is low. Thus, the threshold for <em>trie-write</em> operations is set lower than those for trie-reads. To be clear, this only applies to updating <em>previously existing values</em> (e.g. balances, storage).  Contract code cannot be ‘updated’ and new nodes (of any type) get a timestamp for free when they are created.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">State Data Type</th>
      <th style="text-align: left">Fixed Cost (reads)</th>
      <th style="text-align: left">Fixed Cost (updates)</th>
      <th style="text-align: left">Rent Threshold (reads)</th>
      <th style="text-align: left">Rent Threshold (updates)</th>
      <th style="text-align: left">Rent Cap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Account Balance</td>
      <td style="text-align: left">400 gas (<strong>700</strong>* )</td>
      <td style="text-align: left">9000 gas (<code class="language-plaintext highlighter-rouge">CALL</code> with value)</td>
      <td style="text-align: left">2500 gas</td>
      <td style="text-align: left">1000 gas</td>
      <td style="text-align: left">5000 gas</td>
    </tr>
    <tr>
      <td style="text-align: left">Contract Storage</td>
      <td style="text-align: left">200 gas (<strong>800</strong>*)</td>
      <td style="text-align: left">5000 gas (<code class="language-plaintext highlighter-rouge">SSTORE</code>)</td>
      <td style="text-align: left">2500 gas</td>
      <td style="text-align: left">1000 gas</td>
      <td style="text-align: left">5000 gas</td>
    </tr>
    <tr>
      <td style="text-align: left">Contract Code Hash</td>
      <td style="text-align: left">400 gas (<strong>700</strong>*) (<code class="language-plaintext highlighter-rouge">EXTCODEHASH</code>)</td>
      <td style="text-align: left">N/A</td>
      <td style="text-align: left">2500 gas</td>
      <td style="text-align: left">N/A</td>
      <td style="text-align: left">5000 gas</td>
    </tr>
    <tr>
      <td style="text-align: left">Contract Code</td>
      <td style="text-align: left">700 gas (e.g. <code class="language-plaintext highlighter-rouge">CALL</code>, <code class="language-plaintext highlighter-rouge">EXTCODECOPY</code>)</td>
      <td style="text-align: left">N/A</td>
      <td style="text-align: left">15,000 gas</td>
      <td style="text-align: left">N/A</td>
      <td style="text-align: left">30,000 gas</td>
    </tr>
  </tbody>
</table>

<p><strong>Note</strong>: “N/A” is not applicable (code cannot be “updated”). Values with (*) are those proposed in <a href="(https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP239.md)">RSKIP239</a>, which reprices trie read costs (<code class="language-plaintext highlighter-rouge">BAL</code>, <code class="language-plaintext highlighter-rouge">SLOAD</code>, <code class="language-plaintext highlighter-rouge">EXTCODEHASH</code>).</p>

<p>Updating the timestamp is more resource intensive for <code class="language-plaintext highlighter-rouge">EXTCODECOPY</code> (or <code class="language-plaintext highlighter-rouge">EXTCODESIZE</code>) than for <code class="language-plaintext highlighter-rouge">EXTCODEHASH</code>. This is because <code class="language-plaintext highlighter-rouge">EXTCODEHASH</code> does not require loading contract code. See the Rationale section for <em>additional remarks</em> about these values.</p>

<p><strong>New Nodes</strong>: New nodes (of any type) receive the timestamp of the block they are created in. No advanced rent is collected. If needed (in future) advanced rent payment for new nodes can be incorporated into fixed costs.</p>

<p><strong>Security and DoS:</strong> To increase the costs of IO-DOS attacks, the maximum rent cap is charged for attempting to read data from nodes that do not exist in the trie.</p>

<p><strong>Duration cap:</strong> There is a limit on the amount of time for which rent is accrued. This is set at 3 years. If a node remains untouched for 3 years, then the amount of outstanding rent does not grow any further, it remains capped at that level. Letting rent accumulate forever seems unnecessarily punitive.</p>

<h3 id="computing-a-nodes-rent-time-stamp">Computing a node’s rent time stamp</h3>

<p>Suppose a trie node has nodesize <code class="language-plaintext highlighter-rouge">Size</code> (bytes). Let its current timestamp be <code class="language-plaintext highlighter-rouge">lastRentPaidTime = t_0</code> (seconds) and let the current block’s timestamp be <code class="language-plaintext highlighter-rouge">t_now</code> (seconds). Denote the rental rate by <code class="language-plaintext highlighter-rouge">Rent</code> (gas/byte/second). Denote the <em>relevant</em> (read or write) collection threshold for this node type by <code class="language-plaintext highlighter-rouge">Cutoff</code> (gas), and the rent limit  by <code class="language-plaintext highlighter-rouge">Cap</code> (gas).</p>

<p>Then the <em>outstanding rent</em> for this node is <code class="language-plaintext highlighter-rouge">rent_due = (Size * Rent) * (t_now - t_0)</code>. The amount of rent to be collected (if any) depends on whether the data in the node is modified by the transaction or not.</p>

<ul>
  <li>if <code class="language-plaintext highlighter-rouge">rent_due &lt; Cutoff</code>, then no rent is collected and <code class="language-plaintext highlighter-rouge">lastRentPaidTime</code> remains unchanged.</li>
  <li>if <code class="language-plaintext highlighter-rouge">rent_due &gt; Cutoff</code> but <code class="language-plaintext highlighter-rouge">rent_due &lt; Cap</code>, then the entire outstanding amount is collected and <code class="language-plaintext highlighter-rouge">lastRentPaidTime</code> is set equal to the current block’s timestamp.</li>
  <li>if <code class="language-plaintext highlighter-rouge">rent_due &gt; Cap</code>, then only <code class="language-plaintext highlighter-rouge">Cap</code> is collected. In this case, the timestamp is advanced as follows (using “<code class="language-plaintext highlighter-rouge">//</code>” for <strong>division with round down</strong>)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* If rent due exceeds `Cap`*/
t_paid = Cap//(Size * Rent) /* time for which rent is paid (`//` is division with round down)*/
t_new = t_0 + t_paid /* update the timestamp */
</code></pre></div></div>

<p><strong>Example 1.</strong> Suppose a transaction uses the <code class="language-plaintext highlighter-rouge">SLOAD</code> opcode to read the value of a storage cell with outstanding rent of 1600 gas. If this cell is not modified by the transaction, then no rent is collected, since the amount due is less than the threshold for reads (2500 gas). However, if the same transaction <em>modifies</em> the value contained in the cell using <code class="language-plaintext highlighter-rouge">SSTORE</code>, then the minimum threshold for rent collection is 1000 gas. In this case, the full amount of rent due (1600) is collected  and the timestamp is updated to the current block’s timestamp.</p>

<p><strong>Example 2.</strong> A contract with 5000 bytes of code has not been touched since it was deployed 2 years ago. The amount of rent due is approximately <code class="language-plaintext highlighter-rouge">(5000+128) * 15 * 2 = 15400</code>. The first user to call this contract will be charged the rent cap of 40,000 gas. This payment will <em>advance</em> the contract’s rent timestamp by <code class="language-plaintext highlighter-rouge">40000/(15 *5128) = 0.52</code> years  i.e about 6 months.</p>

<h3 id="tracking-and-collection-mechanics">Tracking and collection mechanics</h3>

<p>All trie nodes <em>accessed</em>, <em>modified</em> or <em>created</em> by a transaction are automatically checked and added to rent-tracking caches. Users cannot select or exclude individual rent payments.</p>

<p>One way of implementing the system is to have three caches of value-containing nodes:</p>

<ol>
  <li>a <em>set</em> of all trie nodes seen thus far during transaction execution</li>
  <li>a <em>map</em> of all trie nodes whose rent timestamps are to be updated along with their individual (updated) timestamps. Some of these nodes will also have updated values (e.g <code class="language-plaintext highlighter-rouge">SSTORE</code>).</li>
  <li>a <em>set</em> of newly created tries nodes. All of them will receive the timestamp of the current block.</li>
</ol>

<p>These caches are passed along to all child calls, so that rent tracking does not kick in more than once for any node irrespective of call depth. After a transaction has been fully processed, the caches are iterated and the updated values and timestamps are committed to the state trie.</p>

<h3 id="gas-counters-and-error-handling">Gas counters and Error Handling</h3>

<p>Rent is consumed from the same gas counter as usual, sourced initially from a transaction’s <code class="language-plaintext highlighter-rouge">gaslimit</code> field. The <code class="language-plaintext highlighter-rouge">usedGas</code> tracker should include both execution and rent gas consumption.</p>

<p>Usually, when there is an <em>unhandled exception</em> at any call depth, TX stops and all state changes are reverted. Any gas used thus far is not refunded. This philosophy must be maintained for storage rent as well. If state changes are reverted at any call depth, due to an error, then all associated rent updates must also be reverted. Not doing so can introduce unintended side effects.</p>

<p>However, if timestamps are not updated following a revert, then it seems unfair to consume all the rent “collected” for those updates. Therefore, a <em>separate</em> <code class="language-plaintext highlighter-rouge">usedRentGas</code> counter should be implemented to handle call reversions or exceptions. If a transaction ends because of a OOG exception or REVERT, then 25% of the storage rent gas used so far (<code class="language-plaintext highlighter-rouge">usedRentGas</code>)  is consumed as compensation for computation and IO costs. Recall that rent is also intended as a deterrence against DoS attacks, so we cannot refund all of the rent accounted for, even if timestamps remain unchanged.</p>

<p>If an error at some call depth is handled in a way that transaction execution can proceed, then only the timestamp changes associated with the failed call (and its subcalls) need to be reverted. Again, 75% of gas used for rent in the failed call should be refunded to the caller.</p>

<h4 id="dependencies">Dependencies</h4>
<p>The limits on variable costs in this proposal are based  on “re-priced” gascosts from a related proposal, RSKIP239. While these proposals can be adopted independently, we think it is beneficial to make the current proposal (RSKIP240) dependent on RSKIP239.</p>

<h2 id="rationale">Rationale</h2>

<p>The specification already explains much of the rationale. Here we include some additional details.</p>

<h3 id="rent-triggers-and-caps">Rent triggers and caps</h3>

<p>The cost of writing a rent timestamp to the trie is an unavoidable accounting cost of implementing storage rent. Lacking data to perform an accurate cost-benefit analysis, we adopt a heuristic and conservative approach.</p>

<p>The cost of <em>updating</em> a value in a storage cell is 5000 gas (<code class="language-plaintext highlighter-rouge">SSTORE</code>). Meanwhile, a <em>value-transferring</em> <code class="language-plaintext highlighter-rouge">CALL</code> costs 9000 gas, which apart from a call stipend of 2300 gas, must also cover the cost of <em>two</em> account updates (the caller’s and callee’s). Thus, for account nodes and storage cells, the cost or re-writing data to state trie is around 4000 or 5000 gas. The cost for writing contract code to the trie is much higher - about 200 gas <em>per byte</em> is charged for <code class="language-plaintext highlighter-rouge">CREATE</code>.</p>

<p>However, larger thresholds decrease the frequency with which rent is collected, which lowers the informativeness of the rent timestamp. So, we propose a smaller value of 2500 gas for storage cells and account nodes. This value corresponds to their approximate annual rent. For the rental cap, we use 5000 gas, which is what the rent would be if an account or storage cell remains untouched for 2 years. For contract code, we set the threshold higher, at 15,000 gas with a cap of 30,000 gas. Trying to spread the storage rent for a contract across many users (for “fairness”) would require too many trie updates.</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>As already mentioned, this change needs a hard fork. In most cases, increasing the <code class="language-plaintext highlighter-rouge">gaslimit</code> should enough to account for rent payments. RPC method to <code class="language-plaintext highlighter-rouge">estimate_gas</code> will provide reasonable guidance. However, there can be some breaking changes.</p>

<p><em>Value-transferring</em> <code class="language-plaintext highlighter-rouge">CALL</code>s cost 9000 gas. From this 9000, an amount 2300 gas is subtracted as a <em>call stipend</em> and passed to the <em>receiving</em> contract. The stipend is intended to cover the cost for logging the value transfer. If the receiving contract performs any  <code class="language-plaintext highlighter-rouge">BAL</code> or <code class="language-plaintext highlighter-rouge">SLOAD</code> operations as part of logging, and if enough rent has accumulated in those accounts or storage cells, then some CALLs may fail.</p>

<p>Contracts that make CALLs to external contacts with specific gas limits can also fail. Such patterns have been discouraged for quite some time now, at least since EIP-150, which increased awareness that gas costs can change  and developers should not make their execution logic rely on the gas schedule.</p>

<p>We think such breaks will be rare in RSK. We also note that the Ethereum community has deliberated and implemented potentially breaking changes of similar magnitude, most recently EIP-2929 which increased trie read operations by 3X.</p>

<h2 id="implementations">Implementations</h2>

<p>Previously, the authors implemented a version with significant overlap with the current proposal. That implementation is being modified and will be shared with the community. This RSKIP will be modified with updated information at that point.</p>

<h3 id="implementation-notes-rskj">Implementation notes (RSKJ)</h3>

<p>Trie related</p>
<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">long</code> for <code class="language-plaintext highlighter-rouge">lastRentPaidTime</code> with a default value of -1 (minus one). This value can help distinguish missing timestamps (which will default to 0). Recall that the trie data structure is also used for other tries (transactions, receipts)</li>
  <li>RSKJ currently uses an <em>implicit</em> node version number <code class="language-plaintext highlighter-rouge">01</code> as part of <code class="language-plaintext highlighter-rouge">flags</code> (bit positions 6, 7). For serialization, these bit positions should be changed to version 2 i.e. <code class="language-plaintext highlighter-rouge">10</code> in <code class="language-plaintext highlighter-rouge">flags</code>.</li>
  <li>Can use <code class="language-plaintext highlighter-rouge">nodeVersion</code> 0 when reading nodes with <code class="language-plaintext highlighter-rouge">Orchid</code> serialization format using <code class="language-plaintext highlighter-rouge">fromMessageOrchid()</code>. This will not affect encoding or hashing for Orchid.</li>
  <li>the trie <code class="language-plaintext highlighter-rouge">put(key, value)</code>  method has to be <em>generalized</em> to <code class="language-plaintext highlighter-rouge">put(key, value, lastRentPaidTime)</code> to incorporate  <code class="language-plaintext highlighter-rouge">lastRentPaidTime</code>. The default value <code class="language-plaintext highlighter-rouge">put(key, value, -1</code> can be used for puts that do not need a timestamp (e.g. version 1 nodes, transaction tires, receipts tries)</li>
</ul>

<h2 id="test-cases">Test Cases</h2>

<p>Incomplete (tests have to be specified more clearly and additional tests to be added)</p>

<ul>
  <li>trie tests, check timestamps, node versioning (serialization, trie hashes)</li>
  <li>check rent computation with and without caps on variable costs</li>
  <li>check gas estimation</li>
  <li>check OOG refunds</li>
</ul>

<h2 id="references">References</h2>

<p>[1] Sergio Demian Lerner, “RSK Rootstock Platform Whitepaper”, https://www.rsk.co/Whitepapers/RSK-White-Paper-Updated.pdf</p>

<p>[2] Alexey Akhunov, “State Fees (formerly State rent) pre-EIP proposal version 3” https://ethresear.ch/t/state-fees-formerly-state-rent-pre-eip-proposal-version-3/4996</p>

<p>[3]  Avatar Felföldi Zsolt, “A pay-for-storage model for evolving tree hashed data structures”, https://gist.github.com/zsfelfoldi/a207d216b3fa9ae4be6abe7a5d8e68d8</p>

<p>[4] Sergio Demian Lerner, “Blockchain State Storage Revised”, https://bitslog.com/2018/01/22/storage-rent-revised</p>

<h3 id="copyright">Copyright</h3>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer>
    <div class="footer_cont">
        <div class="footer_box">
            <ul class="social-media-list"><li><a href="https://github.com/rsksmart/RSKIPs" target="_blank" rel="noopener"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Visit on Github</span></a></li></ul>
        </div>
    </div>
</footer><script src="../assets/js/dark_mode.js"></script>
    <script src="../../assets/js/dark_mode.js"></script>
  </body>

</html>
